define token instr64(64)
	t64_opcode = (56, 63)
	t64_addr1  = (44, 55)
	t64_addr2  = (32, 43)
	t64_imm32  = ( 0, 31)
;

addr1_64: reloc is t64_addr1 [reloc = (t64_addr1 << 2);] {
	export *[ram]:$(ADDRSIZE) reloc;
}

imm32_64: immed is t64_imm32 [immed = 0 + t64_imm32;] {
	local tmp:$(REGSIZE) = immed;
	export tmp;
}

:str addr1_64, imm32_64 is t64_opcode=0x09 & addr1_64 & imm32_64 {
	addr1_64 = imm32_64;
}

:cmp addr1_64, imm32_64 is t64_opcode=0x11 & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = addr1_64;
	resultflags2(tmp, imm32_64);
	affectflags();
}

:cmpp addr1_64, imm32_64 is t64_opcode=0x12 & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = *:4 addr1_64;
	addr1_64 = addr1_64 + 1;
	resultflags2(tmp, imm32_64);
	affectflags();
}

:add addr1_64, imm32_64 is t64_opcode=0x19 & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = addr1_64;
	local res:$(REGSIZE) = tmp + imm32_64;
	addr1_64 = res;

	addflags(tmp, imm32_64);
	resultflags(res);
	affectflags();
}

:op_21 addr1_64 is t64_opcode=0x21 & t64_opcode & addr1_64 { __unkown_op(t64_opcode:1, addr1_64); }

:sub addr1_64, imm32_64 is t64_opcode=0x29 & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = addr1_64;
	local res:$(REGSIZE) = tmp - imm32_64;
	addr1_64 = res;

	subflags(tmp, imm32_64);
	resultflags(res);
	affectflags();
}

:and addr1_64, imm32_64 is t64_opcode=0x39 & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = addr1_64;
	local res:$(REGSIZE) = tmp & imm32_64;
	addr1_64 = res;

	logicflags();
	affectflags();
}

:or addr1_64, imm32_64 is t64_opcode=0x3A & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = addr1_64;
	local res:$(REGSIZE) = tmp | imm32_64;
	addr1_64 = res;

	logicflags();
	affectflags();
}

:xor addr1_64, imm32_64 is t64_opcode=0x49 & addr1_64 & imm32_64 {
	local tmp:$(REGSIZE) = addr1_64;
	local res:$(REGSIZE) = tmp ^ imm32_64;
	addr1_64 = res;

	logicflags();
	affectflags();
}

#pseudo ops for better decomp

define token pseudoInstr64(64)
	t64_double_opcode1 = (56, 63)
	t64_double_branch1 = (32, 43)
	t64_double_cond1   = (56, 59)
	t64_double_opcode2 = (24, 31)
	t64_double_branch2 = ( 0, 11)
	t64_double_cond2   = (24, 27)
;

doubleBranchAddressSame: reloc is t64_double_branch1 [reloc = (t64_double_branch1 << 2);] {
	export *[rom]:$(ADDRSIZE) reloc;
}

cc2: "ge" is t64_double_cond1=3 & t64_double_cond2=2        { tmp:1 = ZR || NG; export tmp; } #first bgt second beq
cc2: "ge" is t64_double_cond1=2 & t64_double_cond2=3        { tmp:1 = ZR || NG; export tmp; } #first beq second bgt
cc2: "le" is t64_double_cond1=4 & t64_double_cond2=2        { tmp:1 = !NG; export tmp; } #first blt second beq
cc2: "le" is t64_double_cond1=2 & t64_double_cond2=4        { tmp:1 = !NG; export tmp; } #first beq second blt
DOUBLECOND: cc2 is cc2 { if (!cc2) goto inst_next; }   # Execute conditionally

:_b^DOUBLECOND doubleBranchAddressSame is DOUBLECOND & (t64_double_opcode1=0xE2|t64_double_opcode1=0xE3|t64_double_opcode1=0xE4) & (t64_double_opcode2=0xE2|t64_double_opcode2=0xE3|t64_double_opcode2=0xE4) & t64_double_branch1=t64_double_branch2 & doubleBranchAddressSame {
	build DOUBLECOND;
	goto doubleBranchAddressSame;
}
